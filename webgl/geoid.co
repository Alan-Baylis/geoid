# Geoid
# Author: Steven Ruppert
# For the Spring 2013 CSCI447 Scientific Visualization class at Colorado School
# of Mines

# this comment appears in the compiled source:
/* This file (geoid.js) is compiled from geoid.co. Please view the
original commented source there. */

"use strict"

canvas = document.getElementById \canvas

canvas{clientWidth: width, clientHeight: height} = document.documentElement

{width, height} = canvas

try
  window.gl =
    canvas.getContext \webgl or canvas.getContext \experimental-webgl

if gl!?
  alert "Sorry, it looks like your browser doesn't support WebGL, or webGL is \
    disabled!"
  throw new Error "no webgl ;_;"

window.gl = WebGLDebugUtils.makeDebugContext gl

# I don't like typing in gl all the time, so I will attach CONSTANTS to the
# global context. Don't do this at home, kids.
for k, v in gl => window[k] = v if /^[A-Z_]+$/.test k

gl
  &viewport   0 0 width, height
  &clearColor 0 0 0 1 # black
  &clear      COLOR_BUFFER_BIT | DEPTH_BUFFER_BIT

var rotation, current-rot, fov, distance

!function reset-stage
  rotation := mat4.identity!
  current-rot := mat4.identity!
  fov := 15deg
  distance := 1 / Math.tan(radians(fov) / 2)

reset-stage!

$ \zoom-in  .addEventListener \click !-> --fov
$ \zoom-out .addEventListener \click !-> ++fov

addWheelListener document.body, !->
  fov += it.deltaY / Math.abs it.deltaY

ctx = document.createElement \canvas .getContext \2d

function gen-noise width, height
  ctx.createImageData width, height
    &data
      for i til width * height * 4 by 4
        &[i] = &[i + 1] = if Math.random! >= 0.5 then 255 else 0
        &[i + 2] = &[i + 3] = 255

export buffers = {}

const
  latBands = 30
  lonBands = 30

noise-tex = gl.createTexture!

function image-processing-set
  framebuffer : gl.createFramebuffer!
  texture : gl.createTexture!
  renderbuffer : gl.createRenderbuffer!

!function setup-framebuffer {framebuffer, renderbuffer, texture}
  gl.pixelStorei gl.UNPACK_FLIP_Y_WEBGL, true
  gl.bindTexture gl.TEXTURE_2D, texture
  gl.texParameteri gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR
  gl.texParameteri gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR
  tw = 2048; th = 1024
  gl.texImage2D gl.TEXTURE_2D, 0, gl.RGBA, tw, th, 0, gl.RGBA, gl.UNSIGNED_BYTE, null

  gl.bindFramebuffer gl.FRAMEBUFFER, framebuffer
  renderbuffer
    gl.bindRenderbuffer gl.RENDERBUFFER, &
    gl.renderbufferStorage gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, tw, th

  gl.framebufferTexture2D gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D,
    texture, 0
  gl.framebufferRenderbuffer gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER,
    renderbuffer

  gl.bindFramebuffer gl.FRAMEBUFFER, null

noise-transport = image-processing-set!
orthogonal-lic = image-processing-set!
advection = image-processing-set!
blend = image-processing-set!

setup-buffers = !->
  noise = gen-noise 2048 1024

  gl.pixelStorei gl.UNPACK_FLIP_Y_WEBGL, true
  gl.bindTexture gl.TEXTURE_2D, noise-tex
  gl.texImage2D gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, noise
  gl.texParameteri gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR
  gl.texParameteri gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR
  gl.generateMipmap gl.TEXTURE_2D

  setup-framebuffer noise-transport
  setup-framebuffer orthogonal-lic
  setup-framebuffer advection
  setup-framebuffer blend

  modelCoords = []

  texCoords = []
  for lat to latBands
    theta = lat * Math.PI / latBands
    sT = Math.sin theta; cT = Math.cos theta

    for lon to lonBands
      phi = lon * 2 * Math.PI / lonBands
      sP = Math.sin phi; cP = Math.cos phi

      modelCoords.push cP * sT, cT, sP * sT
      texCoords.push 1 - (lon/lonBands), 1 - (lat / latBands)

  idx = []
  for lat til latBands
    for lon til lonBands
      fst = lat * (lonBands + 1) + lon
      snd = fst + lonBands + 1

      idx.push do
        fst
        fst + 1
        snd
        snd
        fst + 1
        snd + 1

  buffers <<<
    modelCoord : create-buffer gl, new Float32Array(modelCoords)
    texCoord   : create-buffer gl, new Float32Array(texCoords)

    idx        : with gl.createBuffer!
      gl.bindBuffer ELEMENT_ARRAY_BUFFER, &
      gl.bufferData do
        ELEMENT_ARRAY_BUFFER
        new Uint16Array(idx)
        STATIC_DRAW
    basic-quad: create-buffer gl, new Float32Array [] =
      -1 -1
       1 -1
       1  1
      -1  1
    basic-quad-tex: create-buffer gl, new Float32Array [] =
       0  0
       1  0
       1  1
       0  1
    basic-quad-indices: create-buffer gl, new Uint16Array([0 1 2 0 2 3]),
      ELEMENT_ARRAY_BUFFER

num-triangles = latBands * lonBands * 6

p =
  globe           : load \globe gl
  noise-transport : load \noiseTransport gl
  orthogonal-lic  : load \orthogonalLic gl
  advection       : load \advection gl
  blend           : load \blend gl

export draw = !->
  # first: random noise injection and initial advection
  gl.useProgram p.noise-transport
  gl
    &viewport 0 0 2048 1024
    &disable     DEPTH_TEST
    &disable     CULL_FACE
  gl.bindFramebuffer gl.FRAMEBUFFER, noise-transport.framebuffer
  gl.clear COLOR_BUFFER_BIT | DEPTH_BUFFER_BIT

  gl.activeTexture gl.TEXTURE0
  gl.bindTexture gl.TEXTURE_2D, texture
  gl.getUniformLocation p.noise-transport, \texture
    gl.uniform1i &, 0
  
  # use random offset of noise
  uniform gl, p.noise-transport, \randomOffset \2f Math.random!, Math.random!

  gl.activeTexture gl.TEXTURE1
  gl.bindTexture gl.TEXTURE_2D, noise-tex
  gl.getUniformLocation p.noise-transport, \noise
    gl.uniform1i &, 1

  bind-buffer gl, p.noise-transport, \vertexCoord, buffers.basic-quad, 2
  bind-buffer gl, p.noise-transport, \texCoord, buffers.basic-quad-tex, 2

  gl.bindBuffer ELEMENT_ARRAY_BUFFER, buffers.basic-quad-indices
  gl.drawElements TRIANGLES, 6, UNSIGNED_SHORT, 0

  # 2nd orthogonal LIC
  gl.useProgram p.orthogonal-lic
  gl
    &viewport 0 0 2048 1024
    &disable     DEPTH_TEST
    &disable     CULL_FACE
  gl.bindFramebuffer gl.FRAMEBUFFER, orthogonal-lic.framebuffer
  gl.clear COLOR_BUFFER_BIT | DEPTH_BUFFER_BIT

  gl.activeTexture gl.TEXTURE0
  gl.bindTexture gl.TEXTURE_2D, texture
  gl.getUniformLocation p.orthogonal-lic, \oceanCurrent
    gl.uniform1i &, 0

  gl.activeTexture gl.TEXTURE1
  gl.bindTexture gl.TEXTURE_2D, noise-transport.texture
  gl.getUniformLocation p.orthogonal-lic, \transportedNoise
    gl.uniform1i &, 1

  bind-buffer gl, p.orthogonal-lic, \vertexCoord, buffers.basic-quad, 2
  bind-buffer gl, p.orthogonal-lic, \texCoord, buffers.basic-quad-tex, 2

  gl.bindBuffer ELEMENT_ARRAY_BUFFER, buffers.basic-quad-indices
  gl.drawElements TRIANGLES, 6, UNSIGNED_SHORT, 0

  # 3rd part 1: advect previous display along field
  gl.useProgram p.advection
  gl
    &viewport 0 0 2048 1024
    &disable     DEPTH_TEST
    &disable     CULL_FACE
  gl.bindFramebuffer gl.FRAMEBUFFER, advection.framebuffer
  gl.clear COLOR_BUFFER_BIT | DEPTH_BUFFER_BIT

  gl.activeTexture gl.TEXTURE0
  gl.bindTexture gl.TEXTURE_2D, texture
  gl.getUniformLocation p.advection, \oceanCurrent
    gl.uniform1i &, 0

  gl.activeTexture gl.TEXTURE1
  gl.bindTexture gl.TEXTURE_2D, blend.texture
  gl.getUniformLocation p.advection, \previousTexture
    gl.uniform1i &, 1

  bind-buffer gl, p.advection, \vertexCoord, buffers.basic-quad, 2
  bind-buffer gl, p.advection, \texCoord, buffers.basic-quad-tex, 2

  gl.bindBuffer ELEMENT_ARRAY_BUFFER, buffers.basic-quad-indices
  gl.drawElements TRIANGLES, 6, UNSIGNED_SHORT, 0

  # 3rd part 2: blend new orthogonal LIC with advected previous display
  gl.useProgram p.blend
  gl
    &viewport 0 0 2048 1024
    &disable     DEPTH_TEST
    &disable     CULL_FACE
  gl.bindFramebuffer gl.FRAMEBUFFER, blend.framebuffer
  gl.clear COLOR_BUFFER_BIT | DEPTH_BUFFER_BIT

  gl.activeTexture gl.TEXTURE0
  gl.bindTexture gl.TEXTURE_2D, orthogonal-lic.texture
  gl.getUniformLocation p.blend, \orthogonalLIC
    gl.uniform1i &, 0

  gl.activeTexture gl.TEXTURE1
  gl.bindTexture gl.TEXTURE_2D, advection.texture
  gl.getUniformLocation p.blend, \advected
    gl.uniform1i &, 1

  gl.activeTexture gl.TEXTURE2
  gl.bindTexture gl.TEXTURE_2D, texture
  gl.getUniformLocation p.blend, \oceanCurrent
    gl.uniform1i &, 2

  bind-buffer gl, p.orthogonal-lic, \vertexCoord, buffers.basic-quad, 2
  bind-buffer gl, p.orthogonal-lic, \texCoord, buffers.basic-quad-tex, 2

  gl.bindBuffer ELEMENT_ARRAY_BUFFER, buffers.basic-quad-indices
  gl.drawElements TRIANGLES, 6, UNSIGNED_SHORT, 0

  gl.useProgram p.globe
  gl
    &viewport 0 0 width, height
    &enable     DEPTH_TEST
    &enable     CULL_FACE
  gl.bindFramebuffer gl.FRAMEBUFFER, null
  gl.clear COLOR_BUFFER_BIT | DEPTH_BUFFER_BIT

  if current-rot!? then current-rot := mat4.identity! # XXX weird bug
  rot = mat4.multiply current-rot, rotation, mat4.create!

  uniform gl, p.globe, \NormalMatrix \Matrix3fv mat4.toMat3 rot

  uniform gl, p.globe, \ProjectionMatrix \Matrix4fv \
    mat4.perspective fov, width / height, 0.1 100.0 # distance - 1, distance + 3

  model-view = mat4.identity!
  mat4.translate model-view, [0,0, -(distance + 1)]
  mat4.multiply  model-view, rot

  uniform gl, p.globe, \ModelViewMatrix \Matrix4fv model-view

  gl.activeTexture gl.TEXTURE0
  gl.bindTexture gl.TEXTURE_2D, blend.texture
  gl.getUniformLocation p.globe, \texture
    gl.uniform1i &, 0

  gl.activeTexture gl.TEXTURE1
  gl.bindTexture gl.TEXTURE_2D, texture
  gl.getUniformLocation p.globe, \oceanCurrent
    gl.uniform1i &, 1



  bind-buffer gl, p.globe, \modelCoord, buffers.modelCoord, 3
  bind-buffer gl, p.globe, \texCoord, buffers.texCoord, 2

  gl.bindBuffer ELEMENT_ARRAY_BUFFER, buffers.idx
  gl.drawElements TRIANGLES, num-triangles, UNSIGNED_SHORT, 0

  requestAnimationFrame draw

window.requestAnimationFrame = window.mozRequestAnimationFrame
                            or window.webkitRequestAnimationFrame

# load texture
texture = gl.createTexture!
new Image
  &onload = !->
    gl.pixelStorei gl.UNPACK_FLIP_Y_WEBGL, true
    gl.bindTexture gl.TEXTURE_2D, texture
    gl.texImage2D gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this
    gl.texParameteri gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR
    gl.texParameteri gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST
    gl.generateMipmap gl.TEXTURE_2D

    draw!

  &src = \ocean-current.png

setup-buffers!

# handling mouse rotation

point-under = (x,y) ->
  {left, top} = canvas.getBoundingClientRect!

  # normalize to [-1, 1]
  x =   (x - left) * 2 / (width - 1 ) - 1
  y = -((y - top ) * 2 / (height - 1) - 1)

  det = 1 - x*x - y*y

  if det >= 0
    [x, y, Math.sqrt det]
  else
    [x / Math.sqrt(x*x + y*y), y / Math.sqrt(x*x + y*y), 0]

canvas
  &addEventListener \mousedown !({clientX: i0, clientY: j0}) ->
    &style.cursor = \move

    p = point-under i0, j0

    rotate = !({clientX: i, clientY: j}) ->
      q = point-under i, j
      cp = vec3.direction [0 0 0] p
      cq = vec3.direction [0 0 0] q

      angle = Math.acos vec3.dot(cp, cq) / (vec3.length(cp) * vec3.length(cq))
      axis = vec3.cross cp, cq

      current-rot := mat4.rotate do
        mat4.identity!
        angle
        axis

    &addEventListener \mousemove rotate

    stop = let ran = false
      !->
        if not ran
          ran := true

          mat4.multiply current-rot, rotation, rotation
          current-rot := mat4.identity!

        &style.cursor = \pointer
        &removeEventListener \mousemove rotate
        &removeEventListener \mouseup stop
        &removeEventListener \mouseleave stop

    &addEventListener \mouseup stop
    &addEventListener \mouseleave stop

