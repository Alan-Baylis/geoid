# Geoid
# Author: Steven Ruppert
# For the Spring 2013 CSCI447 Scientific Visualization class at Colorado School
# of Mines

# this comment appears in the compiled source:
/* This file (geoid.js) is compiled from geoid.co. Please view the
original commented source there. */

"use strict"

canvas = document.getElementById \canvas

canvas{clientWidth: width, clientHeight: height} = document.documentElement

{width, height} = canvas

# resize
window.addEventListener \resize debounce 250ms !->
  canvas{clientWidth: width, clientHeight: height} = document.documentElement
  {width, height} := canvas

try
  window.gl =
    canvas.getContext \webgl or canvas.getContext \experimental-webgl

if gl!?
  alert "Sorry, it looks like your browser doesn't support WebGL, or webGL is \
    disabled!"
  throw new Error "no webgl ;_;"

window.gl = WebGLDebugUtils.makeDebugContext gl

# I don't like typing in gl all the time, so I will attach CONSTANTS to the
# global context. Don't do this at home, kids.
for k, v in gl => window[k] = v if /^[A-Z_]+$/.test k

gl
  &viewport   0 0 width, height
  &clearColor 0 0 0 1 # black
  &clear      COLOR_BUFFER_BIT | DEPTH_BUFFER_BIT

arr = -> Array::slice.call it
rotation =
  try
    new Float32Array get \rotation
  catch
    mat4.identity!
current-rot =
  try
    new Float32Array get \current-rot
  catch
    mat4.identity!
fov = parseInt do
  get(\fov) or 15deg
  10
distance = get \distance or 1 / Math.tan(radians(fov) / 2)

!function reset-stage
  rotation := mat4.identity!
  current-rot := mat4.identity!
  fov := 15deg
  distance := 1 / Math.tan(radians(fov) / 2)

  $(\m)value = 10
  $(\n)value = 3

  $(\blend-ratio)value =  0.95

  $(\forwards)value = 10
  $(\backwards)value = 10
  $(\advection-h)value = 0.5
  $(\advection-steps)value = 10

  min-val.value = 0.3
  max-val.value = 0.7

window.addEventListener \unload !->
  set \rotation arr rotation
  set \current-rot arr current-rot
  set \distance distance
  set \fov fov

  # XXX polyfilled range inputs don't persist themselves
  set \m (parseFloat $(\m)value) || 10
  set \n (parseFloat $(\n)value) || 10

  set \blend-ratio (parseFloat $(\blend-ratio)value) || 0.85

  set \lic-h $(\lic-h).value

  set \forwards $(\forwards).value
  set \backwards $(\backwards).value

  set \advection-h $(\advection-h)value
  set \advection-steps $(\advection-steps)value

  set \min-val min-val.value
  set \max-val max-val.value

$(\m)value = get \m or 10
$(\n)value = get \n or 3

$(\blend-ratio)value = get \blend-ratio or 0.95

$(\forwards)value = get \forwards or 10
$(\backwards)value = get \backwards or 10
$(\advection-h)value = get \advection-h or 0.5
$(\advection-steps)value = get \advection-steps or 10

$ \reset .addEventListener \click reset-stage

$ \zoom-in  .addEventListener \click !-> fov := clamp fov - 1, 1, 100
$ \zoom-out .addEventListener \click !-> fov := clamp fov + 1, 1, 100

# keep min/maxval symmetric
symmetric = $ \symmetric
min-val = $ \min-value
  &value = parseFloat get \min-val or 0.3
max-val = $ \max-value
  &value = parseFloat get \max-val or 0.7

reclamp = !->
  min-val.value = Math.min 0.5 parseFloat min-val.value
  max-val.value = Math.max 0.5 parseFloat max-val.value

reclamp! if symmetric.checked
symmetric.addEventListener \change !-> reclamp! if @checked

min-val.addEventListener \input !->
  if symmetric.checked
    max-val.value = 1 - parseFloat @value
max-val.addEventListener \input !->
  if symmetric.checked
    min-val.value = 1 - parseFloat @value

addWheelListener document.body, !->
  fov := clamp fov + it.deltaY / Math.abs(it.deltaY), 1, 100

ctx = document.createElement \canvas .getContext \2d

function gen-noise width, height
  ctx.createImageData width, height
    &data
      for i til width * height * 4 by 4
        &[i] = &[i + 1] = &[i + 2] = if Math.random! >= 0.5 then 255 else 0
        &[i + 3] = 255

export buffers = {}

const
  latBands = 30
  lonBands = 30

noise-tex = gl.createTexture!

function image-processing-set
  framebuffer : gl.createFramebuffer!
  texture : gl.createTexture!
  renderbuffer : gl.createRenderbuffer!

!function setup-framebuffer {framebuffer, renderbuffer, texture}
  gl.pixelStorei gl.UNPACK_FLIP_Y_WEBGL, true
  gl.bindTexture gl.TEXTURE_2D, texture
  gl.texParameteri gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR
  gl.texParameteri gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR
  tw = 2048; th = 1024
  gl.texImage2D gl.TEXTURE_2D, 0, gl.RGBA, tw, th, 0, gl.RGBA, gl.UNSIGNED_BYTE, null

  gl.bindFramebuffer gl.FRAMEBUFFER, framebuffer
  renderbuffer
    gl.bindRenderbuffer gl.RENDERBUFFER, &
    gl.renderbufferStorage gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, tw, th

  gl.framebufferTexture2D gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D,
    texture, 0
  gl.framebufferRenderbuffer gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER,
    renderbuffer

  gl.bindFramebuffer gl.FRAMEBUFFER, null

noise-transport = image-processing-set!
orthogonal-lic = image-processing-set!
advection = image-processing-set!
blend = image-processing-set!

setup-buffers = !->
  noise = gen-noise 2048 1024

  gl.pixelStorei gl.UNPACK_FLIP_Y_WEBGL, true
  gl.bindTexture gl.TEXTURE_2D, noise-tex
  gl.texImage2D gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, noise
  gl.texParameteri gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR
  gl.texParameteri gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR
  gl.generateMipmap gl.TEXTURE_2D

  setup-framebuffer noise-transport
  setup-framebuffer orthogonal-lic
  setup-framebuffer advection
  setup-framebuffer blend

  modelCoords = []

  texCoords = []
  for lat to latBands
    theta = lat * Math.PI / latBands
    sT = Math.sin theta; cT = Math.cos theta

    for lon to lonBands
      phi = lon * 2 * Math.PI / lonBands
      sP = Math.sin phi; cP = Math.cos phi

      modelCoords.push cP * sT, cT, sP * sT
      texCoords.push 1 - (lon/lonBands), 1 - (lat / latBands)

  idx = []
  for lat til latBands
    for lon til lonBands
      fst = lat * (lonBands + 1) + lon
      snd = fst + lonBands + 1

      idx.push do
        fst
        fst + 1
        snd
        snd
        fst + 1
        snd + 1

  buffers <<<
    modelCoord : create-buffer gl, new Float32Array(modelCoords)
    texCoord   : create-buffer gl, new Float32Array(texCoords)

    idx        : with gl.createBuffer!
      gl.bindBuffer ELEMENT_ARRAY_BUFFER, &
      gl.bufferData do
        ELEMENT_ARRAY_BUFFER
        new Uint16Array(idx)
        STATIC_DRAW
    basic-quad: create-buffer gl, new Float32Array [] =
      -1 -1
       1 -1
       1  1
      -1  1
    basic-quad-tex: create-buffer gl, new Float32Array [] =
       0  0
       1  0
       1  1
       0  1
    basic-quad-indices: create-buffer gl, new Uint16Array([0 1 2 0 2 3]),
      ELEMENT_ARRAY_BUFFER

num-triangles = latBands * lonBands * 6

p =
  globe           : load \globe gl
  noise-transport : load \noiseTransport gl
  orthogonal-lic  : load do
    \orthogonalLic gl
    20, 20
  advection       : load \advection gl, 10
  blend           : load \blend gl

# XXX since the LIC steps are in loops, and GLSL doesn't do loops that can't be 
# unrolled, we must recompile the shader if they change
$ \backwards .addEventListener \change !->
  p.orthogonalLic = load do
    \orthogonalLic gl
    parseInt @value, 10
    parseInt $(\forwards)value, 10
$ \backwards .addEventListener \change !->
  p.orthogonalLic = load do
    \orthogonalLic gl
    parseInt $(\backwards)value, 10
    parseInt @value, 10
$ \advection-steps .addEventListener \change !->
  p.advection = load \advection gl, parseInt(@value, 10)

# the requestAnimationFrame id, so we don't get more than one
var frame

export draw = !->
  # first: random noise injection and initial advection
  gl.useProgram p.noise-transport
  gl
    &viewport 0 0 2048 1024
    &disable     DEPTH_TEST
    &disable     CULL_FACE
  gl.bindFramebuffer gl.FRAMEBUFFER, noise-transport.framebuffer
  gl.clear COLOR_BUFFER_BIT | DEPTH_BUFFER_BIT

  gl.activeTexture gl.TEXTURE0
  gl.bindTexture gl.TEXTURE_2D, texture
  gl.getUniformLocation p.noise-transport, \texture
    gl.uniform1i &, 0
  
  # use random offset of noise to vary over time cheaply
  uniform gl, p.noise-transport, \randomOffset \2f Math.random!, Math.random!

  gl.activeTexture gl.TEXTURE1
  gl.bindTexture gl.TEXTURE_2D, noise-tex
  gl.getUniformLocation p.noise-transport, \noise
    gl.uniform1i &, 1

  bind-buffer gl, p.noise-transport, \vertexCoord, buffers.basic-quad, 2
  bind-buffer gl, p.noise-transport, \texCoord, buffers.basic-quad-tex, 2

  gl.bindBuffer ELEMENT_ARRAY_BUFFER, buffers.basic-quad-indices
  gl.drawElements TRIANGLES, 6, UNSIGNED_SHORT, 0

  # 2nd orthogonal LIC
  gl.useProgram p.orthogonal-lic
  gl
    &viewport 0 0 2048 1024
    &disable     DEPTH_TEST
    &disable     CULL_FACE
  gl.bindFramebuffer gl.FRAMEBUFFER, orthogonal-lic.framebuffer
  gl.clear COLOR_BUFFER_BIT | DEPTH_BUFFER_BIT

  gl.activeTexture gl.TEXTURE0
  gl.bindTexture gl.TEXTURE_2D, texture
  gl.getUniformLocation p.orthogonal-lic, \oceanCurrent
    gl.uniform1i &, 0

  gl.activeTexture gl.TEXTURE1
  gl.bindTexture gl.TEXTURE_2D, noise-transport.texture
  gl.getUniformLocation p.orthogonal-lic, \transportedNoise
    gl.uniform1i &, 1

  gl.getUniformLocation p.orthogonal-lic, \useOrthogonal
    gl.uniform1i &, $(\orthogonal)checked

  gl.getUniformLocation p.orthogonal-lic, \h
    gl.uniform1f &, parseFloat $(\lic-h)value

  bind-buffer gl, p.orthogonal-lic, \vertexCoord, buffers.basic-quad, 2
  bind-buffer gl, p.orthogonal-lic, \texCoord, buffers.basic-quad-tex, 2

  gl.bindBuffer ELEMENT_ARRAY_BUFFER, buffers.basic-quad-indices
  gl.drawElements TRIANGLES, 6, UNSIGNED_SHORT, 0

  # 3rd part 1: advect previous display along field
  gl.useProgram p.advection
  gl
    &viewport 0 0 2048 1024
    &disable     DEPTH_TEST
    &disable     CULL_FACE
  gl.bindFramebuffer gl.FRAMEBUFFER, advection.framebuffer
  gl.clear COLOR_BUFFER_BIT | DEPTH_BUFFER_BIT

  gl.activeTexture gl.TEXTURE0
  gl.bindTexture gl.TEXTURE_2D, texture
  gl.getUniformLocation p.advection, \oceanCurrent
    gl.uniform1i &, 0

  gl.activeTexture gl.TEXTURE1
  gl.bindTexture gl.TEXTURE_2D, blend.texture
  gl.getUniformLocation p.advection, \previousTexture
    gl.uniform1i &, 1

  gl.getUniformLocation p.advection, \h
    gl.uniform1f &, parseFloat($ \advection-h .value)
  #
  # use random offset of noise to vary over time cheaply
  uniform gl, p.advection, \randomOffset \2f Math.random!, Math.random!

  gl.activeTexture gl.TEXTURE2
  gl.bindTexture gl.TEXTURE_2D, noise-tex
  gl.getUniformLocation p.advection, \noise
    gl.uniform1i &, 2

  bind-buffer gl, p.advection, \vertexCoord, buffers.basic-quad, 2
  bind-buffer gl, p.advection, \texCoord, buffers.basic-quad-tex, 2

  gl.bindBuffer ELEMENT_ARRAY_BUFFER, buffers.basic-quad-indices
  gl.drawElements TRIANGLES, 6, UNSIGNED_SHORT, 0

  # 3rd part 2: blend new orthogonal LIC with advected previous display
  gl.useProgram p.blend
  gl
    &viewport 0 0 2048 1024
    &disable     DEPTH_TEST
    &disable     CULL_FACE
  gl.bindFramebuffer gl.FRAMEBUFFER, blend.framebuffer
  gl.clear COLOR_BUFFER_BIT | DEPTH_BUFFER_BIT

  gl.activeTexture gl.TEXTURE0
  gl.bindTexture gl.TEXTURE_2D, orthogonal-lic.texture
  gl.getUniformLocation p.blend, \orthogonalLIC
    gl.uniform1i &, 0

  gl.activeTexture gl.TEXTURE1
  gl.bindTexture gl.TEXTURE_2D, advection.texture
  gl.getUniformLocation p.blend, \advected
    gl.uniform1i &, 1

  gl.activeTexture gl.TEXTURE2
  gl.bindTexture gl.TEXTURE_2D, texture
  gl.getUniformLocation p.blend, \oceanCurrent
    gl.uniform1i &, 2

  gl.getUniformLocation p.blend, \ratio
    gl.uniform1f &, parseFloat $(\blend-ratio)value

  bind-buffer gl, p.orthogonal-lic, \vertexCoord, buffers.basic-quad, 2
  bind-buffer gl, p.orthogonal-lic, \texCoord, buffers.basic-quad-tex, 2

  gl.bindBuffer ELEMENT_ARRAY_BUFFER, buffers.basic-quad-indices
  gl.drawElements TRIANGLES, 6, UNSIGNED_SHORT, 0

  gl.useProgram p.globe
  gl
    &viewport 0 0 width, height
    &enable     DEPTH_TEST
    &enable     CULL_FACE
  gl.bindFramebuffer gl.FRAMEBUFFER, null
  gl.clear COLOR_BUFFER_BIT | DEPTH_BUFFER_BIT

  if current-rot!? then current-rot := mat4.identity! # XXX weird bug
  rot = mat4.multiply current-rot, rotation, mat4.create!

  uniform gl, p.globe, \NormalMatrix \Matrix3fv mat4.toMat3 rot

  uniform gl, p.globe, \ProjectionMatrix \Matrix4fv \
    mat4.perspective fov, width / height, 0.1 100.0 # distance - 1, distance + 3

  model-view = mat4.identity!
  mat4.translate model-view, [0,0, -(distance + 1)]
  mat4.multiply  model-view, rot

  uniform gl, p.globe, \ModelViewMatrix \Matrix4fv model-view

  gl.activeTexture gl.TEXTURE0
  gl.bindTexture gl.TEXTURE_2D, blend.texture
  gl.getUniformLocation p.globe, \texture
    gl.uniform1i &, 0

  gl.activeTexture gl.TEXTURE1
  gl.bindTexture gl.TEXTURE_2D, texture
  gl.getUniformLocation p.globe, \oceanCurrent
    gl.uniform1i &, 1

  gl.activeTexture gl.TEXTURE2
  gl.bindTexture gl.TEXTURE_2D,
    if $(\day)checked then earth-texture else night-texture
  gl.getUniformLocation p.globe, \earthTexture
    gl.uniform1i &, 2

  gl.getUniformLocation p.globe, \mask
    gl.uniform1i &, $(\enable-mask)checked

  gl.getUniformLocation p.globe, \m
    gl.uniform1f &, (parseFloat $(\m)value) || 10

  gl.getUniformLocation p.globe, \n
    gl.uniform1f &, (parseFloat $(\n)value) || 3

  gl.getUniformLocation p.globe, \minVal
    gl.uniform1f &, parseFloat $(\min-value)value || 0

  gl.getUniformLocation p.globe, \maxVal
    gl.uniform1f &, parseFloat $(\max-value)value || 1

  bind-buffer gl, p.globe, \modelCoord, buffers.modelCoord, 3
  bind-buffer gl, p.globe, \texCoord, buffers.texCoord, 2

  gl.bindBuffer ELEMENT_ARRAY_BUFFER, buffers.idx
  gl.drawElements TRIANGLES, num-triangles, UNSIGNED_SHORT, 0

  cancelAnimationFrame frame
  frame := requestAnimationFrame draw

window.requestAnimationFrame = window.mozRequestAnimationFrame
                            or window.webkitRequestAnimationFrame
window.cancelAnimationFrame = window.mozCancelAnimationFrame
                            or window.webkitCancelAnimationFrame

# load texture
texture = gl.createTexture!
new Image
  &onload = !->
    gl.pixelStorei gl.UNPACK_FLIP_Y_WEBGL, true
    gl.bindTexture gl.TEXTURE_2D, texture
    gl.texImage2D gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this
    gl.texParameteri gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR
    gl.texParameteri gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST
    gl.generateMipmap gl.TEXTURE_2D

    draw!

  &src = \ocean-current.png

earth-texture = gl.createTexture!
new Image
  &onload = !->
    gl.pixelStorei gl.UNPACK_FLIP_Y_WEBGL, true
    gl.bindTexture gl.TEXTURE_2D, earth-texture
    gl.texImage2D gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this
    gl.texParameteri gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR
    gl.texParameteri gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST
    gl.generateMipmap gl.TEXTURE_2D

    draw!

  &src = \blue-marble.jpg

night-texture = gl.createTexture!
new Image
  &onload = !->
    gl.pixelStorei gl.UNPACK_FLIP_Y_WEBGL, true
    gl.bindTexture gl.TEXTURE_2D, night-texture
    gl.texImage2D gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this
    gl.texParameteri gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR
    gl.texParameteri gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST
    gl.generateMipmap gl.TEXTURE_2D

    draw!

  &src = \black-marble.jpg

setup-buffers!

# handling mouse rotation

point-under = (x,y) ->
  {left, top} = canvas.getBoundingClientRect!

  # normalize to [-1, 1]
  x =   (x - left) * 2 / (width - 1 ) - 1
  y = -((y - top ) * 2 / (height - 1) - 1)

  det = 1 - x*x - y*y

  if det >= 0
    [x, y, Math.sqrt det]
  else
    [x / Math.sqrt(x*x + y*y), y / Math.sqrt(x*x + y*y), 0]

canvas
  &addEventListener \mousedown !({clientX: i0, clientY: j0}) ->
    &style.cursor = \move

    p = point-under i0, j0

    rotate = !({clientX: i, clientY: j}) ->
      q = point-under i, j
      cp = vec3.direction [0 0 0] p
      cq = vec3.direction [0 0 0] q

      angle = Math.acos vec3.dot(cp, cq) / (vec3.length(cp) * vec3.length(cq))
      axis = vec3.cross cp, cq

      current-rot := mat4.rotate do
        mat4.identity!
        angle
        axis

    &addEventListener \mousemove rotate

    stop = let ran = false
      !->
        if not ran
          ran := true

          mat4.multiply current-rot, rotation, rotation
          current-rot := mat4.identity!

        &style.cursor = \pointer
        &removeEventListener \mousemove rotate
        &removeEventListener \mouseup stop
        &removeEventListener \mouseleave stop

    &addEventListener \mouseup stop
    &addEventListener \mouseleave stop

