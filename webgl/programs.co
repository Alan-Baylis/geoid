# Geoid GLSL programs
# Author: Steven Ruppert

# this comment appears in the compiled source:
/* This file (programs.js) is compiled from programs.co. Please view the
original commented source there. */

"use strict"

programs = {}

export load = (it, ...args) -> programs[it].apply null, args

plain-quad-vertex =  """
  precision mediump float;

  attribute vec2 vertexCoord;
  attribute vec2 texCoord;

  varying vec2 tex;

  void main() {
    tex = texCoord;
    gl_Position = vec4(vertexCoord.xy, 1., 1);
  }
"""

ocean-current-common = """
  // we need all three to be able to interpolate between months.
  // well, we technically don't need 3, but having the previous set
  // makes it easier to look backwards in time.
  uniform sampler2D prevOcean;
  uniform sampler2D curOcean;
  uniform sampler2D nextOccean;

  // log space unpacking.
  // Negative numbers were packed backards into [0, 127].
  // Positive numbers were packed normally into [128, 255];
  //
  // The backwards packing ws done so openGL's billinear interp around 0.5 wouldn't
  // cause large negative numbers to suddenly change into tiny positive numbers if
  // the two real values were e.g. 0.49 and 0.51.
  float unlogComponent(float val) {
    if (val < 0.5) {
      // regularly in space [0, 0.5] so transform to [0, 1], then
      // flip into log space [-10, 0], then make negative
      return -exp(val * -20.);
    } else {
      // regularly in space [0.5, 1.0] so transform to [0, 0.5], then
      // to [0, 10], then subtract to log space [-10, 0];
      return exp((val - 0.5) * 10. - 10.);
    }
  }
  vec2 unlog(vec2 val) {
    return val - vec2(0.5, 0.5);
    //return vec2(unlogComponent(val.x), unlogComponent(val.y));
  }

  // the vector field value from a specific month in a set
  // unpacks the log-space numbers from RGBA channels.
  // layout:
  //
  // 0,1   2,3
  // 4,5   6,7
  // 8,9   10,11
  // 12,13 14,15
  vec2 unpackVal(vec2 coords, float month, sampler2D fieldSet) {
    vec2 start = vec2(
      // left side or right side, i.e. 0 or 0.5
      mod(floor(month / 2.), 2.) / 2.,
      // which layer, 0, 0.25, 0.5, 0.75
      0.75 - floor(month / 4.) / 4.
    );

    vec2 actualCoords = start + coords / vec2(2., 4.);

    if (mod(month, 2.) == 0.) {
      return unlog(texture2D(fieldSet, actualCoords).rg);
    } else {
      return unlog(texture2D(fieldSet, actualCoords).ba);
    }
  }
  // unpack current timestamped field from packed texture
  // see the `octave` folder for details
  //
  // coords is in homogenous [0,1] coords, and will be wrapped.
  // time is in months relative to the start of curOcean.
  //
  // Vector fields are essentially trilinearly interpolated,
  // in 2D for the current timestamp automatically by openGL,
  // and through time by this function. Due to the log-space packing of
  // the fields, openGL's interpolation isn't actually linear, but it's close
  // enough.
  vec2 fieldAt(vec2 coords, float time) {
    // wrap coords to [0, 1]
    coords = coords - floor(coords);

    float monthOffset = fract(time);
    float thisMonth = floor(time);
    float nextMonth = thisMonth + 1.;

    vec2 startVal;
    vec2 endVal;
    if (thisMonth == -1.) {
      startVal = unpackVal(coords, 15., prevOcean);
      endVal   = unpackVal(coords, 0., curOcean);
    } else {
      if(thisMonth == 15.) {
        startVal = unpackVal(coords, 15., curOcean);
        endVal   = unpackVal(coords, 0., nextOccean);
      } else {
        startVal = unpackVal(coords, thisMonth, curOcean);
        endVal   = unpackVal(coords, nextMonth, curOcean);
      }
    }

    return mix(startVal, endVal, monthOffset);
  }
"""

isWater = """
  // a simple boolean lookup to deal with edge effects around continents.
  uniform sampler2D landMask;

  bool isWater(vec2 coords) {
    // no fancy unpacking or wrapping, thankfully
    return texture2D(landMask, coords).r != 0.;
  }
"""

programs <<<
  globe: shader-program do
    vertex: """
      precision mediump float;

      attribute vec3 modelCoord;
      attribute vec2 texCoord;

      varying vec2 tex;

      uniform mat4 ModelViewMatrix;
      uniform mat4 ProjectionMatrix;

      void main() {
        tex = texCoord;

        vec4 WorldCoord = ModelViewMatrix * vec4(modelCoord,1.0);

        gl_Position = ProjectionMatrix * WorldCoord;
      }"""
    fragment: """
      precision mediump float;

      uniform sampler2D texture;

      varying vec2 tex;

      uniform sampler2D earthTexture;

      // tweak variables for masking
      uniform float m;
      uniform float n;

      uniform bool mask;

      // tweak contrast stretch
      uniform float minVal;
      uniform float maxVal;

      #ocean-current-common

      #isWater
      
      uniform float time;

      void main() {
        vec4 pixel = texture2D(texture, tex);

        vec4 landTexture = texture2D(earthTexture, tex);

        // stretch contrast
        float range = maxVal - minVal;
        vec3 normalized = pixel.rgb - vec3(minVal, minVal, minVal);
        pixel.rgb = clamp(normalized / range, vec3(0.,0.,0.), vec3(1.,1.,1.));

        float magnitude = length(fieldAt(tex, time));

        // not in paper, but in 2002 e/l texture advection:
        // masking by magnitude
        vec4 alpha = vec4(1., 1., 1., 1.);
        if (mask) {
          float ratio = min(magnitude / 0.5, 1.);
          alpha = (1. - pow(1. - ratio, m)) * (1. - pow(1. - pixel, vec4(n)));
        }

        vec4 masked = pixel * alpha;

        // slight blue coloration for visual appeal
        masked.b = masked.b / 0.9 + 0.1;

        // mix with earth texture, which is 1 for water and 0 for land
        vec4 landM = texture2D(landMask, tex);
        gl_FragColor = mix(landTexture, masked, landM);
      }"""
    uniforms:
      mask:
        \1i true
      m:
        \1f 10
      n:
        \1f 3
      minVal:
        \1f 0.4
      maxVal:
        \1f 0.6
      time:
        \1f 0
  noise-transport: shader-program do
    vertex: plain-quad-vertex
    fragment: """
      precision mediump float;

      uniform sampler2D noise;

      varying vec2 tex;

      uniform vec2 randomOffset;
      

      #isWater

      void main() {
        if (isWater(tex)) {
          vec2 currentPosition = tex + randomOffset;

          // so, the paper says to advect the noise along the field, but since
          // it's random anyway, I don't get why they bother...
          /*
          vec2 pos = currentPosition;
          float h = 0.125;
          vec2 field = fieldAt(pos);
          for(int i = 0; i < 35; ++i) {
            pos = pos - field * h / size;
            field = fieldAt(pos);
          }
          */

          //gl_FragColor = texture2D(noise, pos);
          gl_FragColor = texture2D(noise, currentPosition);
        } else {
          gl_FragColor = texture2D(noise, tex);
        }
      }
    """
  orthogonal-lic: shader-program do
    vertex: plain-quad-vertex
    fragment: (stepsForwards, stepsBackwards) -> """
      precision mediump float;

      uniform sampler2D transportedNoise;

      varying vec2 tex;

      #ocean-current-common

      uniform bool useOrthogonal;

      vec2 licFieldAt(vec2 coords, float time) {
        vec2 val = fieldAt(coords, time);
        if (useOrthogonal) {
          return vec2(-val.y, val.x);
        } else {
          return val;
        }
      }

      uniform float time;

      #isWater

      uniform vec2 size;
      uniform float h;

      // loops have to be unrolled so use global state and recompile instead
      // TODO better way to do this
      const int stepsBackwards = #stepsBackwards;
      const int stepsForwards = #stepsForwards;

      void main() {
        if (isWater(tex)) {
          // LIC backwards and forwards
          vec3 pixel = vec3(0., 0., 0.);
          vec2 pos = tex;

          vec2 field = licFieldAt(pos, time);
          for(int i = 0; i < stepsBackwards; ++i) {
            pixel = pixel + texture2D(transportedNoise, pos).rgb;
            pos = pos - field * h / size;
            field = licFieldAt(pos, time);
          }
          pos = tex;
          field = licFieldAt(pos, time);
          for(int i = 0; i < stepsForwards; ++i) {
            pixel = pixel + texture2D(transportedNoise, pos).rgb;
            pos = pos + field * h / size;
            field = licFieldAt(pos, time);
          }

          // average
          pixel = pixel / #{stepsForwards + stepsBackwards}.0;

          gl_FragColor = vec4(pixel, 1.);
        } else {
          gl_FragColor = texture2D(transportedNoise, tex);
        }
      }
    """
    uniforms:
      size:
        \2f 1024 512
      h:
        \1f 0.75
      useOrthogonal:
        \1i true
      time:
        \1f 0.0

  advection: shader-program do
    vertex: plain-quad-vertex
    fragment: (steps) -> """
      precision mediump float;

      uniform sampler2D previousTexture;

      #ocean-current-common

      #isWater

      // when out of bounds, pull new noise
      uniform sampler2D noise;
      uniform vec2 randomOffset;

      varying vec2 tex;

      uniform float time;

      uniform vec2 size;

      uniform float h;

      void main() {
        if (isWater(tex)) {
          vec2 currentPosition = tex;

          vec2 pos = tex;
          vec2 field = fieldAt(pos, time);
          for(int i = 0; i < #steps; ++i) {
            pos = pos - field * h / size;
            field = fieldAt(pos, time);
          }
          gl_FragColor = texture2D(previousTexture, pos);
        } else {
          // inject noise into the system at boundaries, otherwise there are
          // streak artifacts since the noise isn't transported.
          gl_FragColor = texture2D(noise, tex + randomOffset);
        }
      }
    """
    uniforms:
      size:
        \2f 1024 512
      h:
        \1f 0.125
  blend: shader-program do
    vertex: plain-quad-vertex
    fragment: """
      precision mediump float;

      uniform sampler2D orthogonalLIC;
      uniform sampler2D advected;

      varying vec2 tex;

      uniform float ratio;

      void main() {
        vec4 pixel   = mix(texture2D(orthogonalLIC, tex)
                          ,texture2D(advected     , tex)
                          ,ratio);

        gl_FragColor = pixel;
      }
    """
    uniforms:
      ratio:
        \1f 0.85

