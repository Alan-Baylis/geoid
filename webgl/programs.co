# Geoid GLSL programs
# Author: Steven Ruppert

# this comment appears in the compiled source:
/* This file (programs.js) is compiled from programs.co. Please view the
original commented source there. */

"use strict"

programs = {}

export load = (it, gl) -> programs[it] gl

plain-quad-vertex =  """
  precision mediump float;

  attribute vec2 vertexCoord;
  attribute vec2 texCoord;

  varying vec2 tex;

  void main() {
    tex = texCoord;
    gl_Position = vec4(vertexCoord.xy, 1., 1);
  }
"""

programs <<<
  globe: shader-program do
    vertex: """
      precision mediump float;

      attribute vec3 modelCoord;
      attribute vec2 texCoord;

      varying vec2 tex;

      uniform mat4 ModelViewMatrix;
      uniform mat4 ProjectionMatrix;

      void main() {
        tex = texCoord;

        vec4 WorldCoord = ModelViewMatrix * vec4(modelCoord,1.0);

        gl_Position = ProjectionMatrix * WorldCoord;
      }"""
    fragment: """
      precision mediump float;

      uniform sampler2D texture;

      varying vec2 tex; // coords

      void main() {
        gl_FragColor = texture2D(texture, tex);
      }"""
  noise-transport: shader-program do
    vertex: plain-quad-vertex
    fragment: """
      precision mediump float;

      uniform sampler2D field;
      uniform sampler2D noise;

      varying vec2 tex;

      // transform packed texture field
      vec2 fieldAt(vec2 coords) {
        vec3 val = texture2D(field, coords).xyz;
        return vec2(val.x - 0.5, val.y - 0.5);
      }

      bool isWater(vec2 coords) {
        vec3 val = texture2D(field, coords).xyz;
        return val.z != 0.0;
      }

      vec2 size = vec2(1024., 512.);

      void main() {
        if (isWater(tex)) {
          vec2 currentPosition = tex;
          vec2 field = fieldAt(tex);

          float h = 10.0;
          vec2 advectedPosition = currentPosition + field * h / size;

          gl_FragColor = vec4(texture2D(noise, advectedPosition));
        } else {
          gl_FragColor = vec4(0, 0., 0., 1.0);
        }
      }
    """
  orthogonal-lic: shader-program do
    vertex: plain-quad-vertex
    fragment: """
      precision mediump float;

      uniform sampler2D oceanCurrent;
      uniform sampler2D transportedNoise;

      varying vec2 tex;

      // transform packed texture field
      vec2 orthogonalFieldAt(vec2 coords) {
        vec3 val = texture2D(oceanCurrent, coords).xyz;
        return vec2(-(val.y - 0.5), val.x - 0.5);
      }

      bool isWater(vec2 coords) {
        vec3 val = texture2D(oceanCurrent, coords).xyz;
        return val.z != 0.0;
      }

      vec2 size = vec2(1024., 512.);

      void main() {
        if (isWater(tex)) {
          float h = 1.0;

          // LIC backwards and forwards
          vec3 pixel = vec3(0.0, 0.0, 0.0);
          vec2 pos = tex;

          vec2 field = orthogonalFieldAt(pos);
          for(int i = 0; i < 25; ++i) {
            pixel = pixel + texture2D(transportedNoise, pos).rgb;
            pos = pos - field * h / size;
            field = orthogonalFieldAt(pos);
          }
          pos = tex;
          field = orthogonalFieldAt(pos);
          for(int i = 0; i < 25; ++i) {
            pixel = pixel + texture2D(transportedNoise, pos).rgb;
            pos = pos + field * h / size;
            field = orthogonalFieldAt(pos);
          }

          // average
          pixel = pixel / 50.0;

          gl_FragColor = vec4(pixel, 1.0);
        } else {
          gl_FragColor = vec4(0, 0., 0., 1.0);
        }
      }
    """
  advection: shader-program do
    vertex: plain-quad-vertex
    fragment: """
      precision mediump float;

      uniform sampler2D oceanCurrent;
      uniform sampler2D previousTexture;

      varying vec2 tex;

      // transform packed texture field
      vec2 fieldAt(vec2 coords) {
        vec3 val = texture2D(oceanCurrent, coords).xyz;
        return vec2(val.x - 0.5, val.y - 0.5);
      }

      bool isWater(vec2 coords) {
        vec3 val = texture2D(oceanCurrent, coords).xyz;
        return val.z != 0.0;
      }

      vec2 size = vec2(1024., 512.);

      void main() {
        if (isWater(tex)) {
          vec2 currentPosition = tex;
          vec2 field = fieldAt(tex);

          float h = 1.0;
          vec2 advectedPosition = currentPosition + field * h / size;

          gl_FragColor = vec4(texture2D(previousTexture, advectedPosition));
        } else {
          gl_FragColor = vec4(0, 0., 0., 1.0);
        }
      }
    """
  blend: shader-program do
    vertex: plain-quad-vertex
    fragment: """
      precision mediump float;

      uniform sampler2D orthogonalLIC;
      uniform sampler2D advected;

      varying vec2 tex;

      void main() {
        gl_FragColor = texture2D(orthogonalLIC, tex) * 0.10
                     + texture2D(advected     , tex) * 0.90;
      }
    """

