# Geoid GLSL programs
# Author: Steven Ruppert

# this comment appears in the compiled source:
/* This file (programs.js) is compiled from programs.co. Please view the
original commented source there. */

"use strict"

programs = {}

export load = (it, gl) -> programs[it] gl

plain-quad-vertex =  """
  precision mediump float;

  attribute vec2 vertexCoord;
  attribute vec2 texCoord;

  varying vec2 tex;

  void main() {
    tex = texCoord;
    gl_Position = vec4(vertexCoord.xy, 1., 1);
  }
"""

programs <<<
  globe: shader-program do
    vertex: """
      precision mediump float;

      attribute vec3 modelCoord;
      attribute vec2 texCoord;

      varying vec2 tex;

      uniform mat4 ModelViewMatrix;
      uniform mat4 ProjectionMatrix;

      void main() {
        tex = texCoord;

        vec4 WorldCoord = ModelViewMatrix * vec4(modelCoord,1.0);

        gl_Position = ProjectionMatrix * WorldCoord;
      }"""
    fragment: """
      precision mediump float;

      uniform sampler2D texture;

      varying vec2 tex; // coords

      uniform sampler2D oceanCurrent;
      uniform sampler2D earthTexture;

      bool isWater(vec2 coords) {
        vec3 val = texture2D(oceanCurrent, coords).xyz;
        return val.z != 0.0;
      }

      // transform packed texture field
      vec2 fieldAt(vec2 coords) {
        vec3 val = texture2D(oceanCurrent, coords).xyz;
        return vec2(val.x - 0.5, val.y - 0.5);
      }

      // tweak variables for masking
      uniform float m;
      uniform float n;

      uniform bool mask;

      void main() {
        if (isWater(tex)) {
          vec4 pixel = texture2D(texture, tex);

          float magnitude = length(fieldAt(tex));

          // not in paper, but in 2002 e/l texture advection:
          // masking by magnitude
          vec4 alpha = vec4(1., 1., 1., 1.);
          if (mask) {
            float ratio = min(magnitude / 0.5, 1.);
            alpha = (1. - pow(1. - ratio, m)) * (1. - pow(1. - pixel, vec4(n)));
          }

          gl_FragColor = pixel * alpha;
        } else {
          gl_FragColor = texture2D(earthTexture, tex);
        }
      }"""
    uniforms:
      mask:
        \1i true
      m:
        \1f 10
      n:
        \1f 3
  noise-transport: shader-program do
    vertex: plain-quad-vertex
    fragment: """
      precision mediump float;

      uniform sampler2D field;
      uniform sampler2D noise;

      varying vec2 tex;

      uniform vec2 randomOffset;

      // transform packed texture field
      vec2 fieldAt(vec2 coords) {
        vec3 val = texture2D(field, coords).xyz;
        return vec2(val.x - 0.5, val.y - 0.5);
      }

      bool isWater(vec2 coords) {
        vec3 val = texture2D(field, coords).xyz;
        return val.z != 0.0;
      }

      vec2 size = vec2(1024., 512.);

      void main() {
        if (isWater(tex)) {
          vec2 currentPosition = tex + randomOffset;
          vec2 field = fieldAt(tex);

          float h = 10.0;
          vec2 advectedPosition = currentPosition + field * h / size;

          gl_FragColor = vec4(texture2D(noise, advectedPosition));
        } else {
          gl_FragColor = vec4(0, 0., 0., 1.0);
        }
      }
    """
  orthogonal-lic: shader-program do
    vertex: plain-quad-vertex
    fragment: """
      precision mediump float;

      uniform sampler2D oceanCurrent;
      uniform sampler2D transportedNoise;

      varying vec2 tex;

      // transform packed texture field
      vec2 orthogonalFieldAt(vec2 coords) {
        vec3 val = texture2D(oceanCurrent, coords).xyz;
        return vec2(-(val.y - 0.5), val.x - 0.5);
      }

      bool isWater(vec2 coords) {
        vec3 val = texture2D(oceanCurrent, coords).xyz;
        return val.z != 0.0;
      }

      vec2 size = vec2(1024., 512.);

      void main() {
        if (isWater(tex)) {
          float h = 0.75;

          // LIC backwards and forwards
          vec3 pixel = vec3(0.0, 0.0, 0.0);
          vec2 pos = tex;

          vec2 field = orthogonalFieldAt(pos);
          for(int i = 0; i < 25; ++i) {
            pixel = pixel + texture2D(transportedNoise, pos).rgb;
            pos = pos - field * h / size;
            field = orthogonalFieldAt(pos);
          }
          pos = tex;
          field = orthogonalFieldAt(pos);
          for(int i = 0; i < 25; ++i) {
            pixel = pixel + texture2D(transportedNoise, pos).rgb;
            pos = pos + field * h / size;
            field = orthogonalFieldAt(pos);
          }

          // average
          pixel = pixel / 50.0;

          gl_FragColor = vec4(pixel, 1.0);
        } else {
          gl_FragColor = vec4(0, 0., 0., 1.0);
        }
      }
    """
  advection: shader-program do
    vertex: plain-quad-vertex
    fragment: """
      precision mediump float;

      uniform sampler2D oceanCurrent;
      uniform sampler2D previousTexture;

      varying vec2 tex;

      // transform packed texture field
      vec2 fieldAt(vec2 coords) {
        vec3 val = texture2D(oceanCurrent, coords).xyz;
        return vec2(val.x - 0.5, val.y - 0.5);
      }

      bool isWater(vec2 coords) {
        vec3 val = texture2D(oceanCurrent, coords).xyz;
        return val.z != 0.0;
      }

      vec2 size = vec2(1024., 512.);

      void main() {
        if (isWater(tex)) {
          vec2 currentPosition = tex;

          float h = 0.125;

          vec2 pos = tex;
          vec2 field = fieldAt(pos);
          for(int i = 0; i < 35; ++i) {
            pos = pos - field * h / size;
            field = fieldAt(pos);
          }

          gl_FragColor = vec4(texture2D(previousTexture, pos));
        } else {
          gl_FragColor = vec4(0, 0., 0., 1.0);
        }
      }
    """
  blend: shader-program do
    vertex: plain-quad-vertex
    fragment: """
      precision mediump float;

      uniform sampler2D orthogonalLIC;
      uniform sampler2D advected;

      uniform sampler2D oceanCurrent;

      bool isWater(vec2 coords) {
        vec3 val = texture2D(oceanCurrent, coords).xyz;
        return val.z != 0.0;
      }

      // transform packed texture field
      vec2 fieldAt(vec2 coords) {
        vec3 val = texture2D(oceanCurrent, coords).xyz;
        return vec2(val.x - 0.5, val.y - 0.5);
      }

      varying vec2 tex;

      void main() {
        vec4 pixel   = texture2D(orthogonalLIC, tex) * 0.05
                     + texture2D(advected     , tex) * 0.95;

        gl_FragColor = pixel;
      }
    """

